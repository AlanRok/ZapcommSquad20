{"ast":null,"code":"'use strict';\n\nvar assert = require('minimalistic-assert');\nfunction Cipher(options) {\n  this.options = options;\n  this.type = this.options.type;\n  this.blockSize = 8;\n  this._init();\n  this.buffer = new Array(this.blockSize);\n  this.bufferOff = 0;\n  this.padding = options.padding !== false;\n}\nmodule.exports = Cipher;\nCipher.prototype._init = function _init() {\n  // Might be overrided\n};\nCipher.prototype.update = function update(data) {\n  if (data.length === 0) return [];\n  if (this.type === 'decrypt') return this._updateDecrypt(data);else return this._updateEncrypt(data);\n};\nCipher.prototype._buffer = function _buffer(data, off) {\n  // Append data to buffer\n  var min = Math.min(this.buffer.length - this.bufferOff, data.length - off);\n  for (var i = 0; i < min; i++) this.buffer[this.bufferOff + i] = data[off + i];\n  this.bufferOff += min;\n\n  // Shift next\n  return min;\n};\nCipher.prototype._flushBuffer = function _flushBuffer(out, off) {\n  this._update(this.buffer, 0, out, off);\n  this.bufferOff = 0;\n  return this.blockSize;\n};\nCipher.prototype._updateEncrypt = function _updateEncrypt(data) {\n  var inputOff = 0;\n  var outputOff = 0;\n  var count = (this.bufferOff + data.length) / this.blockSize | 0;\n  var out = new Array(count * this.blockSize);\n  if (this.bufferOff !== 0) {\n    inputOff += this._buffer(data, inputOff);\n    if (this.bufferOff === this.buffer.length) outputOff += this._flushBuffer(out, outputOff);\n  }\n\n  // Write blocks\n  var max = data.length - (data.length - inputOff) % this.blockSize;\n  for (; inputOff < max; inputOff += this.blockSize) {\n    this._update(data, inputOff, out, outputOff);\n    outputOff += this.blockSize;\n  }\n\n  // Queue rest\n  for (; inputOff < data.length; inputOff++, this.bufferOff++) this.buffer[this.bufferOff] = data[inputOff];\n  return out;\n};\nCipher.prototype._updateDecrypt = function _updateDecrypt(data) {\n  var inputOff = 0;\n  var outputOff = 0;\n  var count = Math.ceil((this.bufferOff + data.length) / this.blockSize) - 1;\n  var out = new Array(count * this.blockSize);\n\n  // TODO(indutny): optimize it, this is far from optimal\n  for (; count > 0; count--) {\n    inputOff += this._buffer(data, inputOff);\n    outputOff += this._flushBuffer(out, outputOff);\n  }\n\n  // Buffer rest of the input\n  inputOff += this._buffer(data, inputOff);\n  return out;\n};\nCipher.prototype.final = function final(buffer) {\n  var first;\n  if (buffer) first = this.update(buffer);\n  var last;\n  if (this.type === 'encrypt') last = this._finalEncrypt();else last = this._finalDecrypt();\n  if (first) return first.concat(last);else return last;\n};\nCipher.prototype._pad = function _pad(buffer, off) {\n  if (off === 0) return false;\n  while (off < buffer.length) buffer[off++] = 0;\n  return true;\n};\nCipher.prototype._finalEncrypt = function _finalEncrypt() {\n  if (!this._pad(this.buffer, this.bufferOff)) return [];\n  var out = new Array(this.blockSize);\n  this._update(this.buffer, 0, out, 0);\n  return out;\n};\nCipher.prototype._unpad = function _unpad(buffer) {\n  return buffer;\n};\nCipher.prototype._finalDecrypt = function _finalDecrypt() {\n  assert.equal(this.bufferOff, this.blockSize, 'Not enough data to decrypt');\n  var out = new Array(this.blockSize);\n  this._flushBuffer(out, 0);\n  return this._unpad(out);\n};","map":{"version":3,"names":["assert","require","Cipher","options","type","blockSize","_init","buffer","Array","bufferOff","padding","module","exports","prototype","update","data","length","_updateDecrypt","_updateEncrypt","_buffer","off","min","Math","i","_flushBuffer","out","_update","inputOff","outputOff","count","max","ceil","final","first","last","_finalEncrypt","_finalDecrypt","concat","_pad","_unpad","equal"],"sources":["/app/node_modules/des.js/lib/des/cipher.js"],"sourcesContent":["'use strict';\n\nvar assert = require('minimalistic-assert');\n\nfunction Cipher(options) {\n  this.options = options;\n\n  this.type = this.options.type;\n  this.blockSize = 8;\n  this._init();\n\n  this.buffer = new Array(this.blockSize);\n  this.bufferOff = 0;\n  this.padding = options.padding !== false\n}\nmodule.exports = Cipher;\n\nCipher.prototype._init = function _init() {\n  // Might be overrided\n};\n\nCipher.prototype.update = function update(data) {\n  if (data.length === 0)\n    return [];\n\n  if (this.type === 'decrypt')\n    return this._updateDecrypt(data);\n  else\n    return this._updateEncrypt(data);\n};\n\nCipher.prototype._buffer = function _buffer(data, off) {\n  // Append data to buffer\n  var min = Math.min(this.buffer.length - this.bufferOff, data.length - off);\n  for (var i = 0; i < min; i++)\n    this.buffer[this.bufferOff + i] = data[off + i];\n  this.bufferOff += min;\n\n  // Shift next\n  return min;\n};\n\nCipher.prototype._flushBuffer = function _flushBuffer(out, off) {\n  this._update(this.buffer, 0, out, off);\n  this.bufferOff = 0;\n  return this.blockSize;\n};\n\nCipher.prototype._updateEncrypt = function _updateEncrypt(data) {\n  var inputOff = 0;\n  var outputOff = 0;\n\n  var count = ((this.bufferOff + data.length) / this.blockSize) | 0;\n  var out = new Array(count * this.blockSize);\n\n  if (this.bufferOff !== 0) {\n    inputOff += this._buffer(data, inputOff);\n\n    if (this.bufferOff === this.buffer.length)\n      outputOff += this._flushBuffer(out, outputOff);\n  }\n\n  // Write blocks\n  var max = data.length - ((data.length - inputOff) % this.blockSize);\n  for (; inputOff < max; inputOff += this.blockSize) {\n    this._update(data, inputOff, out, outputOff);\n    outputOff += this.blockSize;\n  }\n\n  // Queue rest\n  for (; inputOff < data.length; inputOff++, this.bufferOff++)\n    this.buffer[this.bufferOff] = data[inputOff];\n\n  return out;\n};\n\nCipher.prototype._updateDecrypt = function _updateDecrypt(data) {\n  var inputOff = 0;\n  var outputOff = 0;\n\n  var count = Math.ceil((this.bufferOff + data.length) / this.blockSize) - 1;\n  var out = new Array(count * this.blockSize);\n\n  // TODO(indutny): optimize it, this is far from optimal\n  for (; count > 0; count--) {\n    inputOff += this._buffer(data, inputOff);\n    outputOff += this._flushBuffer(out, outputOff);\n  }\n\n  // Buffer rest of the input\n  inputOff += this._buffer(data, inputOff);\n\n  return out;\n};\n\nCipher.prototype.final = function final(buffer) {\n  var first;\n  if (buffer)\n    first = this.update(buffer);\n\n  var last;\n  if (this.type === 'encrypt')\n    last = this._finalEncrypt();\n  else\n    last = this._finalDecrypt();\n\n  if (first)\n    return first.concat(last);\n  else\n    return last;\n};\n\nCipher.prototype._pad = function _pad(buffer, off) {\n  if (off === 0)\n    return false;\n\n  while (off < buffer.length)\n    buffer[off++] = 0;\n\n  return true;\n};\n\nCipher.prototype._finalEncrypt = function _finalEncrypt() {\n  if (!this._pad(this.buffer, this.bufferOff))\n    return [];\n\n  var out = new Array(this.blockSize);\n  this._update(this.buffer, 0, out, 0);\n  return out;\n};\n\nCipher.prototype._unpad = function _unpad(buffer) {\n  return buffer;\n};\n\nCipher.prototype._finalDecrypt = function _finalDecrypt() {\n  assert.equal(this.bufferOff, this.blockSize, 'Not enough data to decrypt');\n  var out = new Array(this.blockSize);\n  this._flushBuffer(out, 0);\n\n  return this._unpad(out);\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}