{"ast":null,"code":"import { DEFAULT_NAMESPACE, ACTION_TYPE_DELIMITER } from '../constants';\nimport ownKeys from './ownKeys';\nimport get from './get';\nexport default (function (predicate) {\n  return function flatten(map, _temp, partialFlatMap, partialFlatActionType) {\n    var _ref = _temp === void 0 ? {} : _temp,\n      _ref$namespace = _ref.namespace,\n      namespace = _ref$namespace === void 0 ? DEFAULT_NAMESPACE : _ref$namespace,\n      prefix = _ref.prefix;\n    if (partialFlatMap === void 0) {\n      partialFlatMap = {};\n    }\n    if (partialFlatActionType === void 0) {\n      partialFlatActionType = '';\n    }\n    function connectNamespace(type) {\n      var _ref2;\n      if (!partialFlatActionType) return type;\n      var types = type.toString().split(ACTION_TYPE_DELIMITER);\n      var partials = partialFlatActionType.split(ACTION_TYPE_DELIMITER);\n      return (_ref2 = []).concat.apply(_ref2, partials.map(function (p) {\n        return types.map(function (t) {\n          return \"\" + p + namespace + t;\n        });\n      })).join(ACTION_TYPE_DELIMITER);\n    }\n    function connectPrefix(type) {\n      if (partialFlatActionType || !prefix || prefix && new RegExp(\"^\" + prefix + namespace).test(type)) {\n        return type;\n      }\n      return \"\" + prefix + namespace + type;\n    }\n    ownKeys(map).forEach(function (type) {\n      var nextNamespace = connectPrefix(connectNamespace(type));\n      var mapValue = get(type, map);\n      if (predicate(mapValue)) {\n        flatten(mapValue, {\n          namespace: namespace,\n          prefix: prefix\n        }, partialFlatMap, nextNamespace);\n      } else {\n        partialFlatMap[nextNamespace] = mapValue;\n      }\n    });\n    return partialFlatMap;\n  };\n});","map":{"version":3,"names":["DEFAULT_NAMESPACE","ACTION_TYPE_DELIMITER","ownKeys","get","predicate","flatten","map","_temp","partialFlatMap","partialFlatActionType","_ref","_ref$namespace","namespace","prefix","connectNamespace","type","_ref2","types","toString","split","partials","concat","apply","p","t","join","connectPrefix","RegExp","test","forEach","nextNamespace","mapValue"],"sources":["/app/node_modules/redux-actions/es/utils/flattenWhenNode.js"],"sourcesContent":["import { DEFAULT_NAMESPACE, ACTION_TYPE_DELIMITER } from '../constants';\nimport ownKeys from './ownKeys';\nimport get from './get';\nexport default (function (predicate) {\n  return function flatten(map, _temp, partialFlatMap, partialFlatActionType) {\n    var _ref = _temp === void 0 ? {} : _temp,\n        _ref$namespace = _ref.namespace,\n        namespace = _ref$namespace === void 0 ? DEFAULT_NAMESPACE : _ref$namespace,\n        prefix = _ref.prefix;\n\n    if (partialFlatMap === void 0) {\n      partialFlatMap = {};\n    }\n\n    if (partialFlatActionType === void 0) {\n      partialFlatActionType = '';\n    }\n\n    function connectNamespace(type) {\n      var _ref2;\n\n      if (!partialFlatActionType) return type;\n      var types = type.toString().split(ACTION_TYPE_DELIMITER);\n      var partials = partialFlatActionType.split(ACTION_TYPE_DELIMITER);\n      return (_ref2 = []).concat.apply(_ref2, partials.map(function (p) {\n        return types.map(function (t) {\n          return \"\" + p + namespace + t;\n        });\n      })).join(ACTION_TYPE_DELIMITER);\n    }\n\n    function connectPrefix(type) {\n      if (partialFlatActionType || !prefix || prefix && new RegExp(\"^\" + prefix + namespace).test(type)) {\n        return type;\n      }\n\n      return \"\" + prefix + namespace + type;\n    }\n\n    ownKeys(map).forEach(function (type) {\n      var nextNamespace = connectPrefix(connectNamespace(type));\n      var mapValue = get(type, map);\n\n      if (predicate(mapValue)) {\n        flatten(mapValue, {\n          namespace: namespace,\n          prefix: prefix\n        }, partialFlatMap, nextNamespace);\n      } else {\n        partialFlatMap[nextNamespace] = mapValue;\n      }\n    });\n    return partialFlatMap;\n  };\n});"],"mappings":"AAAA,SAASA,iBAAiB,EAAEC,qBAAqB,QAAQ,cAAc;AACvE,OAAOC,OAAO,MAAM,WAAW;AAC/B,OAAOC,GAAG,MAAM,OAAO;AACvB,gBAAgB,UAAUC,SAAS,EAAE;EACnC,OAAO,SAASC,OAAOA,CAACC,GAAG,EAAEC,KAAK,EAAEC,cAAc,EAAEC,qBAAqB,EAAE;IACzE,IAAIC,IAAI,GAAGH,KAAK,KAAK,KAAK,CAAC,GAAG,CAAC,CAAC,GAAGA,KAAK;MACpCI,cAAc,GAAGD,IAAI,CAACE,SAAS;MAC/BA,SAAS,GAAGD,cAAc,KAAK,KAAK,CAAC,GAAGX,iBAAiB,GAAGW,cAAc;MAC1EE,MAAM,GAAGH,IAAI,CAACG,MAAM;IAExB,IAAIL,cAAc,KAAK,KAAK,CAAC,EAAE;MAC7BA,cAAc,GAAG,CAAC,CAAC;IACrB;IAEA,IAAIC,qBAAqB,KAAK,KAAK,CAAC,EAAE;MACpCA,qBAAqB,GAAG,EAAE;IAC5B;IAEA,SAASK,gBAAgBA,CAACC,IAAI,EAAE;MAC9B,IAAIC,KAAK;MAET,IAAI,CAACP,qBAAqB,EAAE,OAAOM,IAAI;MACvC,IAAIE,KAAK,GAAGF,IAAI,CAACG,QAAQ,CAAC,CAAC,CAACC,KAAK,CAAClB,qBAAqB,CAAC;MACxD,IAAImB,QAAQ,GAAGX,qBAAqB,CAACU,KAAK,CAAClB,qBAAqB,CAAC;MACjE,OAAO,CAACe,KAAK,GAAG,EAAE,EAAEK,MAAM,CAACC,KAAK,CAACN,KAAK,EAAEI,QAAQ,CAACd,GAAG,CAAC,UAAUiB,CAAC,EAAE;QAChE,OAAON,KAAK,CAACX,GAAG,CAAC,UAAUkB,CAAC,EAAE;UAC5B,OAAO,EAAE,GAAGD,CAAC,GAAGX,SAAS,GAAGY,CAAC;QAC/B,CAAC,CAAC;MACJ,CAAC,CAAC,CAAC,CAACC,IAAI,CAACxB,qBAAqB,CAAC;IACjC;IAEA,SAASyB,aAAaA,CAACX,IAAI,EAAE;MAC3B,IAAIN,qBAAqB,IAAI,CAACI,MAAM,IAAIA,MAAM,IAAI,IAAIc,MAAM,CAAC,GAAG,GAAGd,MAAM,GAAGD,SAAS,CAAC,CAACgB,IAAI,CAACb,IAAI,CAAC,EAAE;QACjG,OAAOA,IAAI;MACb;MAEA,OAAO,EAAE,GAAGF,MAAM,GAAGD,SAAS,GAAGG,IAAI;IACvC;IAEAb,OAAO,CAACI,GAAG,CAAC,CAACuB,OAAO,CAAC,UAAUd,IAAI,EAAE;MACnC,IAAIe,aAAa,GAAGJ,aAAa,CAACZ,gBAAgB,CAACC,IAAI,CAAC,CAAC;MACzD,IAAIgB,QAAQ,GAAG5B,GAAG,CAACY,IAAI,EAAET,GAAG,CAAC;MAE7B,IAAIF,SAAS,CAAC2B,QAAQ,CAAC,EAAE;QACvB1B,OAAO,CAAC0B,QAAQ,EAAE;UAChBnB,SAAS,EAAEA,SAAS;UACpBC,MAAM,EAAEA;QACV,CAAC,EAAEL,cAAc,EAAEsB,aAAa,CAAC;MACnC,CAAC,MAAM;QACLtB,cAAc,CAACsB,aAAa,CAAC,GAAGC,QAAQ;MAC1C;IACF,CAAC,CAAC;IACF,OAAOvB,cAAc;EACvB,CAAC;AACH,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module"}