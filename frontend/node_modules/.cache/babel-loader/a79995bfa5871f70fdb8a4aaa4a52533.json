{"ast":null,"code":"import { createContext } from \"react\";\nimport openSocket from \"socket.io-client\";\nimport jwt from \"jsonwebtoken\";\nclass ManagedSocket {\n  constructor(socketManager) {\n    this.socketManager = socketManager;\n    this.rawSocket = socketManager.currentSocket;\n    this.callbacks = [];\n    this.joins = [];\n    this.rawSocket.on(\"connect\", () => {\n      if (!this.rawSocket.recovered) {\n        const refreshJoinsOnReady = () => {\n          for (const j of this.joins) {\n            console.debug(\"refreshing join\", j);\n            this.rawSocket.emit(`join${j.event}`, ...j.params);\n          }\n          this.rawSocket.off(\"ready\", refreshJoinsOnReady);\n        };\n        for (const j of this.callbacks) {\n          this.rawSocket.off(j.event, j.callback);\n          this.rawSocket.on(j.event, j.callback);\n        }\n        this.rawSocket.on(\"ready\", refreshJoinsOnReady);\n      }\n    });\n  }\n  on(event, callback) {\n    if (event === \"ready\" || event === \"connect\") {\n      return this.socketManager.onReady(callback);\n    }\n    this.callbacks.push({\n      event,\n      callback\n    });\n    return this.rawSocket.on(event, callback);\n  }\n  off(event, callback) {\n    const i = this.callbacks.findIndex(c => c.event === event && c.callback === callback);\n    this.callbacks.splice(i, 1);\n    return this.rawSocket.off(event, callback);\n  }\n  emit(event, ...params) {\n    if (event.startsWith(\"join\")) {\n      this.joins.push({\n        event: event.substring(4),\n        params\n      });\n      console.log(\"Joining\", {\n        event: event.substring(4),\n        params\n      });\n    }\n    return this.rawSocket.emit(event, ...params);\n  }\n  disconnect() {\n    for (const j of this.joins) {\n      this.rawSocket.emit(`leave${j.event}`, ...j.params);\n    }\n    this.joins = [];\n    for (const c of this.callbacks) {\n      this.rawSocket.off(c.event, c.callback);\n    }\n    this.callbacks = [];\n  }\n}\nclass DummySocket {\n  on(..._) {}\n  off(..._) {}\n  emit(..._) {}\n  disconnect() {}\n}\nconst SocketManager = {\n  currentCompanyId: -1,\n  currentUserId: -1,\n  currentSocket: null,\n  socketReady: false,\n  getSocket: function (companyId) {\n    let userId = null;\n    if (localStorage.getItem(\"userId\")) {\n      userId = localStorage.getItem(\"userId\");\n    }\n    if (!companyId && !this.currentSocket) {\n      return new DummySocket();\n    }\n    if (companyId && typeof companyId !== \"string\") {\n      companyId = `${companyId}`;\n    }\n    if (companyId !== this.currentCompanyId || userId !== this.currentUserId) {\n      if (this.currentSocket) {\n        console.warn(\"closing old socket - company or user changed\");\n        this.currentSocket.removeAllListeners();\n        this.currentSocket.disconnect();\n        this.currentSocket = null;\n      }\n      let token = JSON.parse(localStorage.getItem(\"token\"));\n      const {\n        exp\n      } = jwt.decode(token);\n      if (Date.now() >= exp * 1000) {\n        console.warn(\"Expired token, reload after refresh\");\n        setTimeout(() => {\n          window.location.reload();\n        }, 1000);\n        return new DummySocket();\n      }\n      this.currentCompanyId = companyId;\n      this.currentUserId = userId;\n      if (!token) {\n        return new DummySocket();\n      }\n      this.currentSocket = openSocket(process.env.REACT_APP_BACKEND_URL, {\n        transports: [\"websocket\"],\n        pingTimeout: 18000,\n        pingInterval: 18000,\n        query: {\n          token\n        }\n      });\n      this.currentSocket.on(\"disconnect\", reason => {\n        console.warn(`socket disconnected because: ${reason}`);\n        if (reason.startsWith(\"io \")) {\n          console.warn(\"tryng to reconnect\", this.currentSocket);\n          const {\n            exp\n          } = jwt.decode(token);\n          if (Date.now() - 180 >= exp * 1000) {\n            console.warn(\"Expired token, reloading app\");\n            window.location.reload();\n            return;\n          }\n          this.currentSocket.connect();\n        }\n      });\n      this.currentSocket.on(\"connect\", (...params) => {\n        console.warn(\"socket connected\", params);\n      });\n      this.currentSocket.onAny((event, ...args) => {\n        console.debug(\"Event: \", {\n          socket: this.currentSocket,\n          event,\n          args\n        });\n      });\n      this.onReady(() => {\n        this.socketReady = true;\n      });\n    }\n    return new ManagedSocket(this);\n  },\n  onReady: function (callbackReady) {\n    if (this.socketReady) {\n      callbackReady();\n      return;\n    }\n    this.currentSocket.once(\"ready\", () => {\n      callbackReady();\n    });\n  }\n};\nconst SocketContext = createContext();\nexport { SocketContext, SocketManager };","map":{"version":3,"names":["createContext","openSocket","jwt","ManagedSocket","constructor","socketManager","rawSocket","currentSocket","callbacks","joins","on","recovered","refreshJoinsOnReady","j","console","debug","emit","event","params","off","callback","onReady","push","i","findIndex","c","splice","startsWith","substring","log","disconnect","DummySocket","_","SocketManager","currentCompanyId","currentUserId","socketReady","getSocket","companyId","userId","localStorage","getItem","warn","removeAllListeners","token","JSON","parse","exp","decode","Date","now","setTimeout","window","location","reload","process","env","REACT_APP_BACKEND_URL","transports","pingTimeout","pingInterval","query","reason","connect","onAny","args","socket","callbackReady","once","SocketContext"],"sources":["/app/src/context/Socket/SocketContext.js"],"sourcesContent":["import { createContext } from \"react\";\nimport openSocket from \"socket.io-client\";\nimport jwt from \"jsonwebtoken\";\n\nclass ManagedSocket {\n  constructor(socketManager) {\n    this.socketManager = socketManager;\n    this.rawSocket = socketManager.currentSocket;\n    this.callbacks = [];\n    this.joins = [];\n\n    this.rawSocket.on(\"connect\", () => {\n      if (!this.rawSocket.recovered) {\n        const refreshJoinsOnReady = () => {\n          for (const j of this.joins) {\n            console.debug(\"refreshing join\", j);\n            this.rawSocket.emit(`join${j.event}`, ...j.params);\n          }\n          this.rawSocket.off(\"ready\", refreshJoinsOnReady);\n        };\n        for (const j of this.callbacks) {\n          this.rawSocket.off(j.event, j.callback);\n          this.rawSocket.on(j.event, j.callback);\n        }\n        \n        this.rawSocket.on(\"ready\", refreshJoinsOnReady);\n      }\n    });\n  }\n  \n  on(event, callback) {\n    if (event === \"ready\" || event === \"connect\") {\n      return this.socketManager.onReady(callback);\n    }\n    this.callbacks.push({event, callback});\n    return this.rawSocket.on(event, callback);\n  }\n  \n  off(event, callback) {\n    const i = this.callbacks.findIndex((c) => c.event === event && c.callback === callback);\n    this.callbacks.splice(i, 1);\n    return this.rawSocket.off(event, callback);\n  }\n  \n  emit(event, ...params) {\n    if (event.startsWith(\"join\")) {\n      this.joins.push({ event: event.substring(4), params });\n      console.log(\"Joining\", { event: event.substring(4), params});\n    }\n    return this.rawSocket.emit(event, ...params);\n  }\n  \n  disconnect() {\n    for (const j of this.joins) {\n      this.rawSocket.emit(`leave${j.event}`, ...j.params);\n    }\n    this.joins = [];\n    for (const c of this.callbacks) {\n      this.rawSocket.off(c.event, c.callback);\n    }\n    this.callbacks = [];\n  }\n}\n\nclass DummySocket {\n  on(..._) {}\n  off(..._) {}\n  emit(..._) {}\n  disconnect() {}\n}\n\nconst SocketManager = {\n  currentCompanyId: -1,\n  currentUserId: -1,\n  currentSocket: null,\n  socketReady: false,\n\n  getSocket: function(companyId) {\n    let userId = null;\n    if (localStorage.getItem(\"userId\")) {\n      userId = localStorage.getItem(\"userId\");\n    }\n\n    if (!companyId && !this.currentSocket) {\n      return new DummySocket();\n    }\n\n    if (companyId && typeof companyId !== \"string\") {\n      companyId = `${companyId}`;\n    }\n\n    if (companyId !== this.currentCompanyId || userId !== this.currentUserId) {\n      if (this.currentSocket) {\n        console.warn(\"closing old socket - company or user changed\");\n        this.currentSocket.removeAllListeners();\n        this.currentSocket.disconnect();\n        this.currentSocket = null;\n      }\n\n      let token = JSON.parse(localStorage.getItem(\"token\"));\n      const { exp } = jwt.decode(token);\n\n      if ( Date.now() >= exp*1000) {\n        console.warn(\"Expired token, reload after refresh\");\n        setTimeout(() => {\n          window.location.reload();\n        },1000);\n        return new DummySocket();\n      }\n\n      this.currentCompanyId = companyId;\n      this.currentUserId = userId;\n      \n      if (!token) {\n        return new DummySocket();\n      }\n      \n      this.currentSocket = openSocket(process.env.REACT_APP_BACKEND_URL, {\n        transports: [\"websocket\"],\n        pingTimeout: 18000,\n        pingInterval: 18000,\n        query: { token },\n      });\n      \n      this.currentSocket.on(\"disconnect\", (reason) => {\n        console.warn(`socket disconnected because: ${reason}`);\n        if (reason.startsWith(\"io \")) {\n          console.warn(\"tryng to reconnect\", this.currentSocket);\n          \n          const { exp } = jwt.decode(token);\n          if ( Date.now()-180 >= exp*1000) {\n            console.warn(\"Expired token, reloading app\");\n            window.location.reload();\n            return;\n          }\n\n          this.currentSocket.connect();\n        }        \n      });\n      \n      this.currentSocket.on(\"connect\", (...params) => {\n        console.warn(\"socket connected\", params);\n      })\n      \n      this.currentSocket.onAny((event, ...args) => {\n        console.debug(\"Event: \", { socket: this.currentSocket, event, args });\n      });\n      \n      this.onReady(() => {\n        this.socketReady = true;\n      });\n\n    }\n    \n    return new ManagedSocket(this);\n  },\n  \n  onReady: function( callbackReady ) {\n    if (this.socketReady) {\n      callbackReady();\n      return\n    }\n    \n    this.currentSocket.once(\"ready\", () => {\n      callbackReady();\n    });\n  },\n\n};\n\nconst SocketContext = createContext()\n\nexport { SocketContext, SocketManager };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}